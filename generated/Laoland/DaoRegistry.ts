// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class AdapterAdded extends ethereum.Event {
  get params(): AdapterAdded__Params {
    return new AdapterAdded__Params(this);
  }
}

export class AdapterAdded__Params {
  _event: AdapterAdded;

  constructor(event: AdapterAdded) {
    this._event = event;
  }

  get adapterId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }

  get adapterAddress(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get flags(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class AdapterRemoved extends ethereum.Event {
  get params(): AdapterRemoved__Params {
    return new AdapterRemoved__Params(this);
  }
}

export class AdapterRemoved__Params {
  _event: AdapterRemoved;

  constructor(event: AdapterRemoved) {
    this._event = event;
  }

  get adapterId(): Bytes {
    return this._event.parameters[0].value.toBytes();
  }
}

export class MemberJailed extends ethereum.Event {
  get params(): MemberJailed__Params {
    return new MemberJailed__Params(this);
  }
}

export class MemberJailed__Params {
  _event: MemberJailed;

  constructor(event: MemberJailed) {
    this._event = event;
  }

  get memberAddr(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class MemberUnjailed extends ethereum.Event {
  get params(): MemberUnjailed__Params {
    return new MemberUnjailed__Params(this);
  }
}

export class MemberUnjailed__Params {
  _event: MemberUnjailed;

  constructor(event: MemberUnjailed) {
    this._event = event;
  }

  get memberAddr(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class NewBalance extends ethereum.Event {
  get params(): NewBalance__Params {
    return new NewBalance__Params(this);
  }
}

export class NewBalance__Params {
  _event: NewBalance;

  constructor(event: NewBalance) {
    this._event = event;
  }

  get member(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get tokenAddr(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class ProcessedProposal extends ethereum.Event {
  get params(): ProcessedProposal__Params {
    return new ProcessedProposal__Params(this);
  }
}

export class ProcessedProposal__Params {
  _event: ProcessedProposal;

  constructor(event: ProcessedProposal) {
    this._event = event;
  }

  get proposalId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get processingTime(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get flags(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class SponsoredProposal extends ethereum.Event {
  get params(): SponsoredProposal__Params {
    return new SponsoredProposal__Params(this);
  }
}

export class SponsoredProposal__Params {
  _event: SponsoredProposal;

  constructor(event: SponsoredProposal) {
    this._event = event;
  }

  get proposalId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get flags(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get startingTime(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class SubmittedProposal extends ethereum.Event {
  get params(): SubmittedProposal__Params {
    return new SubmittedProposal__Params(this);
  }
}

export class SubmittedProposal__Params {
  _event: SubmittedProposal;

  constructor(event: SubmittedProposal) {
    this._event = event;
  }

  get proposalId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get flags(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get applicant(): Address {
    return this._event.parameters[2].value.toAddress();
  }
}

export class UpdateDelegateKey extends ethereum.Event {
  get params(): UpdateDelegateKey__Params {
    return new UpdateDelegateKey__Params(this);
  }
}

export class UpdateDelegateKey__Params {
  _event: UpdateDelegateKey;

  constructor(event: UpdateDelegateKey) {
    this._event = event;
  }

  get memberAddress(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newDelegateKey(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class DaoRegistry__inverseRegistryResult {
  value0: Bytes;
  value1: BigInt;

  constructor(value0: Bytes, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromFixedBytes(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class DaoRegistry__proposalsResult {
  value0: Address;
  value1: Address;
  value2: BigInt;

  constructor(value0: Address, value1: Address, value2: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromAddress(this.value0));
    map.set("value1", ethereum.Value.fromAddress(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    return map;
  }
}

export class DaoRegistry extends ethereum.SmartContract {
  static bind(address: Address): DaoRegistry {
    return new DaoRegistry("DaoRegistry", address);
  }

  ETH_TOKEN(): Address {
    let result = super.call("ETH_TOKEN", "ETH_TOKEN():(address)", []);

    return result[0].toAddress();
  }

  try_ETH_TOKEN(): ethereum.CallResult<Address> {
    let result = super.tryCall("ETH_TOKEN", "ETH_TOKEN():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  FINANCING(): Bytes {
    let result = super.call("FINANCING", "FINANCING():(bytes32)", []);

    return result[0].toBytes();
  }

  try_FINANCING(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("FINANCING", "FINANCING():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  GUILD(): Address {
    let result = super.call("GUILD", "GUILD():(address)", []);

    return result[0].toAddress();
  }

  try_GUILD(): ethereum.CallResult<Address> {
    let result = super.tryCall("GUILD", "GUILD():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  LOCKED_LOOT(): Address {
    let result = super.call("LOCKED_LOOT", "LOCKED_LOOT():(address)", []);

    return result[0].toAddress();
  }

  try_LOCKED_LOOT(): ethereum.CallResult<Address> {
    let result = super.tryCall("LOCKED_LOOT", "LOCKED_LOOT():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  LOOT(): Address {
    let result = super.call("LOOT", "LOOT():(address)", []);

    return result[0].toAddress();
  }

  try_LOOT(): ethereum.CallResult<Address> {
    let result = super.tryCall("LOOT", "LOOT():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  MANAGING(): Bytes {
    let result = super.call("MANAGING", "MANAGING():(bytes32)", []);

    return result[0].toBytes();
  }

  try_MANAGING(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("MANAGING", "MANAGING():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  NONVOTING_ONBOARDING(): Bytes {
    let result = super.call(
      "NONVOTING_ONBOARDING",
      "NONVOTING_ONBOARDING():(bytes32)",
      []
    );

    return result[0].toBytes();
  }

  try_NONVOTING_ONBOARDING(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "NONVOTING_ONBOARDING",
      "NONVOTING_ONBOARDING():(bytes32)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  ONBOARDING(): Bytes {
    let result = super.call("ONBOARDING", "ONBOARDING():(bytes32)", []);

    return result[0].toBytes();
  }

  try_ONBOARDING(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("ONBOARDING", "ONBOARDING():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  RAGEQUIT(): Bytes {
    let result = super.call("RAGEQUIT", "RAGEQUIT():(bytes32)", []);

    return result[0].toBytes();
  }

  try_RAGEQUIT(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("RAGEQUIT", "RAGEQUIT():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  SHARES(): Address {
    let result = super.call("SHARES", "SHARES():(address)", []);

    return result[0].toAddress();
  }

  try_SHARES(): ethereum.CallResult<Address> {
    let result = super.tryCall("SHARES", "SHARES():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  TOTAL(): Address {
    let result = super.call("TOTAL", "TOTAL():(address)", []);

    return result[0].toAddress();
  }

  try_TOTAL(): ethereum.CallResult<Address> {
    let result = super.tryCall("TOTAL", "TOTAL():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  VOTING(): Bytes {
    let result = super.call("VOTING", "VOTING():(bytes32)", []);

    return result[0].toBytes();
  }

  try_VOTING(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("VOTING", "VOTING():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  inverseRegistry(param0: Address): DaoRegistry__inverseRegistryResult {
    let result = super.call(
      "inverseRegistry",
      "inverseRegistry(address):(bytes32,uint256)",
      [ethereum.Value.fromAddress(param0)]
    );

    return new DaoRegistry__inverseRegistryResult(
      result[0].toBytes(),
      result[1].toBigInt()
    );
  }

  try_inverseRegistry(
    param0: Address
  ): ethereum.CallResult<DaoRegistry__inverseRegistryResult> {
    let result = super.tryCall(
      "inverseRegistry",
      "inverseRegistry(address):(bytes32,uint256)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new DaoRegistry__inverseRegistryResult(
        value[0].toBytes(),
        value[1].toBigInt()
      )
    );
  }

  memberAddressesByDelegatedKey(param0: Address): Address {
    let result = super.call(
      "memberAddressesByDelegatedKey",
      "memberAddressesByDelegatedKey(address):(address)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toAddress();
  }

  try_memberAddressesByDelegatedKey(
    param0: Address
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "memberAddressesByDelegatedKey",
      "memberAddressesByDelegatedKey(address):(address)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  members(param0: Address): BigInt {
    let result = super.call("members", "members(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBigInt();
  }

  try_members(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("members", "members(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  proposalCount(): BigInt {
    let result = super.call("proposalCount", "proposalCount():(uint64)", []);

    return result[0].toBigInt();
  }

  try_proposalCount(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("proposalCount", "proposalCount():(uint64)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  proposals(param0: BigInt): DaoRegistry__proposalsResult {
    let result = super.call(
      "proposals",
      "proposals(uint64):(address,address,uint256)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );

    return new DaoRegistry__proposalsResult(
      result[0].toAddress(),
      result[1].toAddress(),
      result[2].toBigInt()
    );
  }

  try_proposals(
    param0: BigInt
  ): ethereum.CallResult<DaoRegistry__proposalsResult> {
    let result = super.tryCall(
      "proposals",
      "proposals(uint64):(address,address,uint256)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new DaoRegistry__proposalsResult(
        value[0].toAddress(),
        value[1].toAddress(),
        value[2].toBigInt()
      )
    );
  }

  registry(param0: Bytes): Address {
    let result = super.call("registry", "registry(bytes32):(address)", [
      ethereum.Value.fromFixedBytes(param0)
    ]);

    return result[0].toAddress();
  }

  try_registry(param0: Bytes): ethereum.CallResult<Address> {
    let result = super.tryCall("registry", "registry(bytes32):(address)", [
      ethereum.Value.fromFixedBytes(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  state(): i32 {
    let result = super.call("state", "state():(uint8)", []);

    return result[0].toI32();
  }

  try_state(): ethereum.CallResult<i32> {
    let result = super.tryCall("state", "state():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  isAdapter(adapterAddress: Address): boolean {
    let result = super.call("isAdapter", "isAdapter(address):(bool)", [
      ethereum.Value.fromAddress(adapterAddress)
    ]);

    return result[0].toBoolean();
  }

  try_isAdapter(adapterAddress: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isAdapter", "isAdapter(address):(bool)", [
      ethereum.Value.fromAddress(adapterAddress)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  hasAdapterAccess(adapterAddress: Address, flag: i32): boolean {
    let result = super.call(
      "hasAdapterAccess",
      "hasAdapterAccess(address,uint8):(bool)",
      [
        ethereum.Value.fromAddress(adapterAddress),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(flag))
      ]
    );

    return result[0].toBoolean();
  }

  try_hasAdapterAccess(
    adapterAddress: Address,
    flag: i32
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "hasAdapterAccess",
      "hasAdapterAccess(address,uint8):(bool)",
      [
        ethereum.Value.fromAddress(adapterAddress),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(flag))
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  getAdapterAddress(adapterId: Bytes): Address {
    let result = super.call(
      "getAdapterAddress",
      "getAdapterAddress(bytes32):(address)",
      [ethereum.Value.fromFixedBytes(adapterId)]
    );

    return result[0].toAddress();
  }

  try_getAdapterAddress(adapterId: Bytes): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getAdapterAddress",
      "getAdapterAddress(bytes32):(address)",
      [ethereum.Value.fromFixedBytes(adapterId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  execute(_actionTo: Address, _actionValue: BigInt, _actionData: Bytes): Bytes {
    let result = super.call(
      "execute",
      "execute(address,uint256,bytes):(bytes)",
      [
        ethereum.Value.fromAddress(_actionTo),
        ethereum.Value.fromUnsignedBigInt(_actionValue),
        ethereum.Value.fromBytes(_actionData)
      ]
    );

    return result[0].toBytes();
  }

  try_execute(
    _actionTo: Address,
    _actionValue: BigInt,
    _actionData: Bytes
  ): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "execute",
      "execute(address,uint256,bytes):(bytes)",
      [
        ethereum.Value.fromAddress(_actionTo),
        ethereum.Value.fromUnsignedBigInt(_actionValue),
        ethereum.Value.fromBytes(_actionData)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  submitProposal(applicant: Address): BigInt {
    let result = super.call(
      "submitProposal",
      "submitProposal(address):(uint64)",
      [ethereum.Value.fromAddress(applicant)]
    );

    return result[0].toBigInt();
  }

  try_submitProposal(applicant: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "submitProposal",
      "submitProposal(address):(uint64)",
      [ethereum.Value.fromAddress(applicant)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  isInternalToken(tokenToMint: Address): boolean {
    let result = super.call(
      "isInternalToken",
      "isInternalToken(address):(bool)",
      [ethereum.Value.fromAddress(tokenToMint)]
    );

    return result[0].toBoolean();
  }

  try_isInternalToken(tokenToMint: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isInternalToken",
      "isInternalToken(address):(bool)",
      [ethereum.Value.fromAddress(tokenToMint)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isActiveMember(addr: Address): boolean {
    let result = super.call(
      "isActiveMember",
      "isActiveMember(address):(bool)",
      [ethereum.Value.fromAddress(addr)]
    );

    return result[0].toBoolean();
  }

  try_isActiveMember(addr: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isActiveMember",
      "isActiveMember(address):(bool)",
      [ethereum.Value.fromAddress(addr)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  getProposalFlag(proposalId: BigInt, flag: i32): boolean {
    let result = super.call(
      "getProposalFlag",
      "getProposalFlag(uint64,uint8):(bool)",
      [
        ethereum.Value.fromUnsignedBigInt(proposalId),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(flag))
      ]
    );

    return result[0].toBoolean();
  }

  try_getProposalFlag(
    proposalId: BigInt,
    flag: i32
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "getProposalFlag",
      "getProposalFlag(uint64,uint8):(bool)",
      [
        ethereum.Value.fromUnsignedBigInt(proposalId),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(flag))
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  nbShares(member: Address): BigInt {
    let result = super.call("nbShares", "nbShares(address):(uint256)", [
      ethereum.Value.fromAddress(member)
    ]);

    return result[0].toBigInt();
  }

  try_nbShares(member: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("nbShares", "nbShares(address):(uint256)", [
      ethereum.Value.fromAddress(member)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  nbLoot(member: Address): BigInt {
    let result = super.call("nbLoot", "nbLoot(address):(uint256)", [
      ethereum.Value.fromAddress(member)
    ]);

    return result[0].toBigInt();
  }

  try_nbLoot(member: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("nbLoot", "nbLoot(address):(uint256)", [
      ethereum.Value.fromAddress(member)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  isNotReservedAddress(applicant: Address): boolean {
    let result = super.call(
      "isNotReservedAddress",
      "isNotReservedAddress(address):(bool)",
      [ethereum.Value.fromAddress(applicant)]
    );

    return result[0].toBoolean();
  }

  try_isNotReservedAddress(applicant: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isNotReservedAddress",
      "isNotReservedAddress(address):(bool)",
      [ethereum.Value.fromAddress(applicant)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  tokens(): Array<Address> {
    let result = super.call("tokens", "tokens():(address[])", []);

    return result[0].toAddressArray();
  }

  try_tokens(): ethereum.CallResult<Array<Address>> {
    let result = super.tryCall("tokens", "tokens():(address[])", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddressArray());
  }

  balanceOf(account: Address, tokenAddr: Address): BigInt {
    let result = super.call(
      "balanceOf",
      "balanceOf(address,address):(uint256)",
      [
        ethereum.Value.fromAddress(account),
        ethereum.Value.fromAddress(tokenAddr)
      ]
    );

    return result[0].toBigInt();
  }

  try_balanceOf(
    account: Address,
    tokenAddr: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "balanceOf",
      "balanceOf(address,address):(uint256)",
      [
        ethereum.Value.fromAddress(account),
        ethereum.Value.fromAddress(tokenAddr)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPriorAmount(
    account: Address,
    tokenAddr: Address,
    blockNumber: BigInt
  ): BigInt {
    let result = super.call(
      "getPriorAmount",
      "getPriorAmount(address,address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(account),
        ethereum.Value.fromAddress(tokenAddr),
        ethereum.Value.fromUnsignedBigInt(blockNumber)
      ]
    );

    return result[0].toBigInt();
  }

  try_getPriorAmount(
    account: Address,
    tokenAddr: Address,
    blockNumber: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getPriorAmount",
      "getPriorAmount(address,address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(account),
        ethereum.Value.fromAddress(tokenAddr),
        ethereum.Value.fromUnsignedBigInt(blockNumber)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getCurrentDelegateKey(memberAddr: Address): Address {
    let result = super.call(
      "getCurrentDelegateKey",
      "getCurrentDelegateKey(address):(address)",
      [ethereum.Value.fromAddress(memberAddr)]
    );

    return result[0].toAddress();
  }

  try_getCurrentDelegateKey(memberAddr: Address): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getCurrentDelegateKey",
      "getCurrentDelegateKey(address):(address)",
      [ethereum.Value.fromAddress(memberAddr)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getPreviousDelegateKey(memberAddr: Address): Address {
    let result = super.call(
      "getPreviousDelegateKey",
      "getPreviousDelegateKey(address):(address)",
      [ethereum.Value.fromAddress(memberAddr)]
    );

    return result[0].toAddress();
  }

  try_getPreviousDelegateKey(
    memberAddr: Address
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getPreviousDelegateKey",
      "getPreviousDelegateKey(address):(address)",
      [ethereum.Value.fromAddress(memberAddr)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getPriorDelegateKey(memberAddr: Address, blockNumber: BigInt): Address {
    let result = super.call(
      "getPriorDelegateKey",
      "getPriorDelegateKey(address,uint256):(address)",
      [
        ethereum.Value.fromAddress(memberAddr),
        ethereum.Value.fromUnsignedBigInt(blockNumber)
      ]
    );

    return result[0].toAddress();
  }

  try_getPriorDelegateKey(
    memberAddr: Address,
    blockNumber: BigInt
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getPriorDelegateKey",
      "getPriorDelegateKey(address,uint256):(address)",
      [
        ethereum.Value.fromAddress(memberAddr),
        ethereum.Value.fromUnsignedBigInt(blockNumber)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class FinalizeDaoCall extends ethereum.Call {
  get inputs(): FinalizeDaoCall__Inputs {
    return new FinalizeDaoCall__Inputs(this);
  }

  get outputs(): FinalizeDaoCall__Outputs {
    return new FinalizeDaoCall__Outputs(this);
  }
}

export class FinalizeDaoCall__Inputs {
  _call: FinalizeDaoCall;

  constructor(call: FinalizeDaoCall) {
    this._call = call;
  }
}

export class FinalizeDaoCall__Outputs {
  _call: FinalizeDaoCall;

  constructor(call: FinalizeDaoCall) {
    this._call = call;
  }
}

export class AddAdapterCall extends ethereum.Call {
  get inputs(): AddAdapterCall__Inputs {
    return new AddAdapterCall__Inputs(this);
  }

  get outputs(): AddAdapterCall__Outputs {
    return new AddAdapterCall__Outputs(this);
  }
}

export class AddAdapterCall__Inputs {
  _call: AddAdapterCall;

  constructor(call: AddAdapterCall) {
    this._call = call;
  }

  get adapterId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get adapterAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get flags(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class AddAdapterCall__Outputs {
  _call: AddAdapterCall;

  constructor(call: AddAdapterCall) {
    this._call = call;
  }
}

export class RemoveAdapterCall extends ethereum.Call {
  get inputs(): RemoveAdapterCall__Inputs {
    return new RemoveAdapterCall__Inputs(this);
  }

  get outputs(): RemoveAdapterCall__Outputs {
    return new RemoveAdapterCall__Outputs(this);
  }
}

export class RemoveAdapterCall__Inputs {
  _call: RemoveAdapterCall;

  constructor(call: RemoveAdapterCall) {
    this._call = call;
  }

  get adapterId(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class RemoveAdapterCall__Outputs {
  _call: RemoveAdapterCall;

  constructor(call: RemoveAdapterCall) {
    this._call = call;
  }
}

export class JailMemberCall extends ethereum.Call {
  get inputs(): JailMemberCall__Inputs {
    return new JailMemberCall__Inputs(this);
  }

  get outputs(): JailMemberCall__Outputs {
    return new JailMemberCall__Outputs(this);
  }
}

export class JailMemberCall__Inputs {
  _call: JailMemberCall;

  constructor(call: JailMemberCall) {
    this._call = call;
  }

  get memberAddr(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class JailMemberCall__Outputs {
  _call: JailMemberCall;

  constructor(call: JailMemberCall) {
    this._call = call;
  }
}

export class UnjailMemberCall extends ethereum.Call {
  get inputs(): UnjailMemberCall__Inputs {
    return new UnjailMemberCall__Inputs(this);
  }

  get outputs(): UnjailMemberCall__Outputs {
    return new UnjailMemberCall__Outputs(this);
  }
}

export class UnjailMemberCall__Inputs {
  _call: UnjailMemberCall;

  constructor(call: UnjailMemberCall) {
    this._call = call;
  }

  get memberAddr(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class UnjailMemberCall__Outputs {
  _call: UnjailMemberCall;

  constructor(call: UnjailMemberCall) {
    this._call = call;
  }
}

export class ExecuteCall extends ethereum.Call {
  get inputs(): ExecuteCall__Inputs {
    return new ExecuteCall__Inputs(this);
  }

  get outputs(): ExecuteCall__Outputs {
    return new ExecuteCall__Outputs(this);
  }
}

export class ExecuteCall__Inputs {
  _call: ExecuteCall;

  constructor(call: ExecuteCall) {
    this._call = call;
  }

  get _actionTo(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _actionValue(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get _actionData(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }
}

export class ExecuteCall__Outputs {
  _call: ExecuteCall;

  constructor(call: ExecuteCall) {
    this._call = call;
  }

  get value0(): Bytes {
    return this._call.outputValues[0].value.toBytes();
  }
}

export class SubmitProposalCall extends ethereum.Call {
  get inputs(): SubmitProposalCall__Inputs {
    return new SubmitProposalCall__Inputs(this);
  }

  get outputs(): SubmitProposalCall__Outputs {
    return new SubmitProposalCall__Outputs(this);
  }
}

export class SubmitProposalCall__Inputs {
  _call: SubmitProposalCall;

  constructor(call: SubmitProposalCall) {
    this._call = call;
  }

  get applicant(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SubmitProposalCall__Outputs {
  _call: SubmitProposalCall;

  constructor(call: SubmitProposalCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class SponsorProposalCall extends ethereum.Call {
  get inputs(): SponsorProposalCall__Inputs {
    return new SponsorProposalCall__Inputs(this);
  }

  get outputs(): SponsorProposalCall__Outputs {
    return new SponsorProposalCall__Outputs(this);
  }
}

export class SponsorProposalCall__Inputs {
  _call: SponsorProposalCall;

  constructor(call: SponsorProposalCall) {
    this._call = call;
  }

  get _proposalId(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get sponsoringMember(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class SponsorProposalCall__Outputs {
  _call: SponsorProposalCall;

  constructor(call: SponsorProposalCall) {
    this._call = call;
  }
}

export class ProcessProposalCall extends ethereum.Call {
  get inputs(): ProcessProposalCall__Inputs {
    return new ProcessProposalCall__Inputs(this);
  }

  get outputs(): ProcessProposalCall__Outputs {
    return new ProcessProposalCall__Outputs(this);
  }
}

export class ProcessProposalCall__Inputs {
  _call: ProcessProposalCall;

  constructor(call: ProcessProposalCall) {
    this._call = call;
  }

  get _proposalId(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class ProcessProposalCall__Outputs {
  _call: ProcessProposalCall;

  constructor(call: ProcessProposalCall) {
    this._call = call;
  }
}

export class UpdateDelegateKeyCall extends ethereum.Call {
  get inputs(): UpdateDelegateKeyCall__Inputs {
    return new UpdateDelegateKeyCall__Inputs(this);
  }

  get outputs(): UpdateDelegateKeyCall__Outputs {
    return new UpdateDelegateKeyCall__Outputs(this);
  }
}

export class UpdateDelegateKeyCall__Inputs {
  _call: UpdateDelegateKeyCall;

  constructor(call: UpdateDelegateKeyCall) {
    this._call = call;
  }

  get memberAddr(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get newDelegateKey(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class UpdateDelegateKeyCall__Outputs {
  _call: UpdateDelegateKeyCall;

  constructor(call: UpdateDelegateKeyCall) {
    this._call = call;
  }
}

export class RegisterPotentialNewTokenCall extends ethereum.Call {
  get inputs(): RegisterPotentialNewTokenCall__Inputs {
    return new RegisterPotentialNewTokenCall__Inputs(this);
  }

  get outputs(): RegisterPotentialNewTokenCall__Outputs {
    return new RegisterPotentialNewTokenCall__Outputs(this);
  }
}

export class RegisterPotentialNewTokenCall__Inputs {
  _call: RegisterPotentialNewTokenCall;

  constructor(call: RegisterPotentialNewTokenCall) {
    this._call = call;
  }

  get token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class RegisterPotentialNewTokenCall__Outputs {
  _call: RegisterPotentialNewTokenCall;

  constructor(call: RegisterPotentialNewTokenCall) {
    this._call = call;
  }
}

export class RegisterPotentialNewInternalTokenCall extends ethereum.Call {
  get inputs(): RegisterPotentialNewInternalTokenCall__Inputs {
    return new RegisterPotentialNewInternalTokenCall__Inputs(this);
  }

  get outputs(): RegisterPotentialNewInternalTokenCall__Outputs {
    return new RegisterPotentialNewInternalTokenCall__Outputs(this);
  }
}

export class RegisterPotentialNewInternalTokenCall__Inputs {
  _call: RegisterPotentialNewInternalTokenCall;

  constructor(call: RegisterPotentialNewInternalTokenCall) {
    this._call = call;
  }

  get token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class RegisterPotentialNewInternalTokenCall__Outputs {
  _call: RegisterPotentialNewInternalTokenCall;

  constructor(call: RegisterPotentialNewInternalTokenCall) {
    this._call = call;
  }
}

export class AddToBalanceCall extends ethereum.Call {
  get inputs(): AddToBalanceCall__Inputs {
    return new AddToBalanceCall__Inputs(this);
  }

  get outputs(): AddToBalanceCall__Outputs {
    return new AddToBalanceCall__Outputs(this);
  }
}

export class AddToBalanceCall__Inputs {
  _call: AddToBalanceCall;

  constructor(call: AddToBalanceCall) {
    this._call = call;
  }

  get user(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get token(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class AddToBalanceCall__Outputs {
  _call: AddToBalanceCall;

  constructor(call: AddToBalanceCall) {
    this._call = call;
  }
}

export class SubtractFromBalanceCall extends ethereum.Call {
  get inputs(): SubtractFromBalanceCall__Inputs {
    return new SubtractFromBalanceCall__Inputs(this);
  }

  get outputs(): SubtractFromBalanceCall__Outputs {
    return new SubtractFromBalanceCall__Outputs(this);
  }
}

export class SubtractFromBalanceCall__Inputs {
  _call: SubtractFromBalanceCall;

  constructor(call: SubtractFromBalanceCall) {
    this._call = call;
  }

  get user(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get token(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class SubtractFromBalanceCall__Outputs {
  _call: SubtractFromBalanceCall;

  constructor(call: SubtractFromBalanceCall) {
    this._call = call;
  }
}

export class InternalTransferCall extends ethereum.Call {
  get inputs(): InternalTransferCall__Inputs {
    return new InternalTransferCall__Inputs(this);
  }

  get outputs(): InternalTransferCall__Outputs {
    return new InternalTransferCall__Outputs(this);
  }
}

export class InternalTransferCall__Inputs {
  _call: InternalTransferCall;

  constructor(call: InternalTransferCall) {
    this._call = call;
  }

  get from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get token(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class InternalTransferCall__Outputs {
  _call: InternalTransferCall;

  constructor(call: InternalTransferCall) {
    this._call = call;
  }
}
